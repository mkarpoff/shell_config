"""
" Environment settings
"""
" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %

" I don't care about vi compatability
set nocompatible

" Huawei servers backspace doesn't work...
set backspace=2

" Turn on mouse
set mouse=a

" Set the shell to run bash
set shell=/bin/bash

" To hell with visual and audio bell
set noerrorbells visualbell t_vb=

" Persistent undo history
set undofile
set undodir=$HOME/.vim/undo
set undolevels=1000
set undoreload=10000

" Move viminfo to .vim folder
set viminfo+=n$HOME/.vim/info

" General indenting rules
set autoindent
set tabstop=2
set softtabstop=2
set shiftwidth=2

set encoding=utf-8
scriptencoding=utf-8
set termencoding=utf-8
set term=xterm-256color

if &term == 'xterm-256color' || &term == 'screen-256color'
	let &t_SI = "\<Esc>[5 q"
	let &t_SR = "\<Esc>[3 q"
	let &t_EI = "\<Esc>[1 q"
endif

filetype plugin on


" Navigation Hotkeys for speeding usage
set timeoutlen=1000 ttimeoutlen=10
inoremap jk <Esc>
inoremap JK <Esc>
nnoremap ww <c-w>
tnoremap ww <c-w>
vnoremap ww <c-w>
nnoremap ; :
tnoremap ; :
vnoremap ; :
nnoremap [[ :call b:Compile()<CR>
nnoremap ]] :call b:CompileClean()<CR>
nnoremap \ :cclose<CR>


" TMUX Navigation plugin
if exists('$TMUX')
	packadd vim-tmux-navigator
	let g:tmux_navigator_no_mappings = 1
endif

" Persistent file undo across reopening vim
if !isdirectory($HOME."/.vim/undodir")
	call mkdir($HOME."/.vim/undodir", "p")
endif
set undodir=$HOME/.vim/undodir


" Search Settings
function! HighlightSearch()
	if &hlsearch
		set nohlsearch
		echo 'Search highlight off'
	else
		set hlsearch
		echo 'Search highlight on'
	endif
endfunction
command! -nargs=0 HS call HighlightSearch()
cnoremap <nowait> <expr> hs getcmdtype() ==# ':' && getcmdpos() == 1 ? 'HS' : 'hs'

" Spell Checking
command! SCon setlocal spell spelllang=en_ca
command! SCoff setlocal nospell

" Color Column
function! ColorColumn(col)
	let &colorcolumn=join(range(a:col,999),',')
endfunction
command! -nargs=1 ColorColumn call ColorColumn(<f-args>)

" Show white spacing
set listchars=eol:¬,tab:>•,trail:~,extends:>,precedes:<,space:·
command! WSToggle set invlist


" Close qf if it is only open window
aug QFClose
	au!
	au WinEnter * if winnr('$') == 1 && getbufvar(winbufnr(winnr()), "&buftype") == "quickfix"|q|endif
aug END

" Resize qf
function! AdjustWindowHeight(minheight, maxheight)
	let l = 1
	let n_lines = 0
	let w_width = winwidth(0)
	while l <= line('$')
		" number to float for division
		let l_len = strlen(getline(l)) + 0.0
		let line_width = l_len/w_width
		let n_lines += float2nr(ceil(line_width))
		let l += 1
	endw
	exe max([min([n_lines, a:maxheight]), a:minheight]) . "wincmd _"
endfunction


" Zoom / Restore window.
function! s:ZoomToggle() abort
	if exists('t:zoomed') && t:zoomed
		execute t:zoom_winrestcmd
		let t:zoomed = 0
	else
		let t:zoom_winrestcmd = winrestcmd()
		resize
		vertical resize
		let t:zoomed = 1
	endif
endfunction
command! ZoomToggle call s:ZoomToggle()
nnoremap <silent> <C-w>f :ZoomToggle<CR>
tnoremap <silent> <C-w>f <C-w>:ZoomToggle<CR>

" make using make! instead of make
cnoremap <nowait> <expr> make getcmdtype() ==# ':' && getcmdpos() == 1 ? 'make!' : 'make'

augroup vimrc
	" Uncomment the following to have Vim jump to the last position when
	" reopening a file
	if has('autocmd')
		au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
			\| exe "normal! g'\"" | endif
	endif
	autocmd BufNewFile,BufRead *.x86 set filetype=gas
	autocmd BufNewFile,BufRead *.log set filetype=log
	autocmd BufNewFile,BufRead *.h set filetype=cpp

augroup END

" Assume I want syntax highlighting
colorscheme desert-mkarpoff
syntax enable

let g:airline_powerline_fonts=1

silent! helptags ALL
