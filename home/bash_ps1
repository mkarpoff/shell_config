#!/bin/env bash
# Prompt function because PROMPT_COMMAND is awesome

if [[ $- == *i* ]]; then

if [[ -z "${GIT_PS1}" ]]; then
	export GIT_PS1=1
fi
declare -A syms=( [RA]='' [RB]='' [LB]='' [LA]='' [BRANCH]='' [CLEAN]='√' [DIRTY]='×' [LOCAL]='←' [STASH]='→' [AHEAD]='↑' [BHIND]='↓' )
#declare -A syms=( [RA]='' [RB]='' [LB]='' [LA]='' [BRANCH]='' [CLEAN]='✓√○' [DIRTY]='✗●×' [LOCAL]='←◄' [STASH]='☇→►◌' [AHEAD]='↑▲' [BHIND]='↓▼' )
if [ "$(tput colors)" == "256" ]; then
declare -A colors=(
	[TERMBLKF]="$(tput sgr0)"
	[TERMBLKB]="$(tput sgr0)"
	[BLKF]="$(tput setaf  236)"
	[BLKB]="$(tput setab  236)"
	[REDF]="$(tput setaf  160)"
	[REDB]="$(tput setab  160)"
	[GREF]="$(tput setaf  70)"
	[GREB]="$(tput setab  70)"
	[YELF]="$(tput setaf  178)"
	[YELB]="$(tput setab  178)"
	[BLUF]="$(tput setaf  32)"
	[BLUB]="$(tput setab  32)"
	[PRPF]="$(tput setaf  096)"
	[PRPB]="$(tput setab  096)"
	[AQUF]="$(tput setaf  37)"
	[AQUB]="$(tput setab  37)"
	[GRYF]="$(tput setaf  240)"
	[GRYB]="$(tput setab  240)"
	)
else
declare -A colors=(
	[BLKF]="\\[$(tput setaf  0)\\]"
	[BLKB]="\\[$(tput setab  0)\\]"
	[REDF]="\\[$(tput setaf  1)\\]"
	[REDB]="\\[$(tput setab  1)\\]"
	[GREF]="\\[$(tput setaf  2)\\]"
	[GREB]="\\[$(tput setab  2)\\]"
	[YELF]="\\[$(tput setaf  3)\\]"
	[YELB]="\\[$(tput setab  3)\\]"
	[BLUF]="\\[$(tput setaf  4)\\]"
	[BLUB]="\\[$(tput setab  4)\\]"
	[PRPF]="\\[$(tput setaf  5)\\]"
	[PRPB]="\\[$(tput setab  5)\\]"
	[AQUF]="\\[$(tput setaf  6)\\]"
	[AQUB]="\\[$(tput setab  6)\\]"
	[GRYF]="\\[$(tput setaf  8)\\]"
	[GRYB]="\\[$(tput setab  8)\\]"
	)
fi

# Nested shell level
if [[ $SHLVL != "1" ]]; then
	readonly shlvl="${colors[GRYB]} ${SHLVL} ${colors[GRYF]}"
else
	readonly shlvl="${colors[GRYF]}${colors[GRYB]} "
fi

# Display Username
readonly usrin="${colors[GREB]}${syms[RA]}${colors[BLKF]} ${HOSTNAME}  ${colors[GREF]}"
readonly clock="${colors[GREF]}${colors[BLKB]}${LA}${colors[GREB]}${colors[BLKF]} \\@"
readonly ps1_2="${colors[TERMBLKB]}${colors[GRYF]}${syms[RA]}$(tput el)$(tput sgr0)"

function git_dirty() {
	local _dirty=$(git status --porcelain 2>/dev/null| wc -l )
	if (( _dirty > 0 ))
	then
		echo "${colors[REDF]}${syms[DIRTY]} $_dirty${syms[LOCAL]}"
	else
		echo "${colors[GREF]}${syms[CLEAN]} "
	fi
}
function git_stash() {
	local _stash=$(git stash list 2>/dev/null| wc -l)
	if (( _stash > 0 )); then
		echo "${_stash}${syms[STASH]}"
	fi
}

function git_ahead() {
	local _ahead=$(git rev-list "@{u}..HEAD" 2>/dev/null| wc -l)
	if (( _ahead > 0 )); then
		echo "${_ahead}${syms[AHEAD]}"
	fi
}

function git_behind() {
	local _behind=$(git rev-list "HEAD..@{u}" 2>/dev/null| wc -l)
	if (( _behind > 0 )); then
		echo "${_behind}${syms[BHIND]}"
	fi
}

function git_prompt() {
	# GIT STUFF
	local git_repo_name=$(git rev-parse --show-toplevel 2>/dev/null)
	git_repo_name=$(basename ${git_repo_name} 2>/dev/null)
	if [ "$git_repo_name" == "" ] ; then
		return 0
	fi
	local _branch=$(git symbolic-ref HEAD 2>/dev/null )
	_branch=${_branch#refs/heads/} # apparently faster than sed
	echo "${colors[YELB]}${syms[RA]}${colors[BLKF]} ${syms[BRANCH]}${git_repo_name}:${_branch}$(git_dirty &)$(git_stash &)$(git_ahead &)$(git_behind &)${colors[YELF]}"
}

function set_prompt() {
	local last_cmd="$?"
	local branch=$(git_prompt&)

	# Virtual Env stuff
	local venv
	if [[ $VIRTUAL_ENV != "" ]]; then
		venv="${colors[PRPB]}${syms[RA]}${colors[BLKF]} ${VIRTUAL_ENV##*/}  ${colors[PRPF]}"
	else
		venv=""
	fi


	local path
	# Check to make sure the path isn't going to run over the clock. Will display
	# current directory and parent directory if it will run over the clock
	path="${colors[BLUB]}${syms[RA]}${colors[BLKF]} \w ${colors[BLUF]}"

	local ps1_1
	ps1_1="$(tput el1)$(tput cub $(tput cols))$(tput hpa 0)${shlvl}${usrin}${branch}${venv}${path}${colors[TERMBLKB]}${colors[BLUF]}${syms[RA]}$(tput sgr0)"

	export PS1="${ps1_1}\\r\\n$(tput el1)${ps1_2}"
}

	export PS2="${ps1_2}"
	export PROMPT_COMMAND=set_prompt
fi
