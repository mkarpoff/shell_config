#!/bin/env bash
# Prompt function because PROMPT_COMMAND is awesome

if [[ $- == *i* ]]; then

if [[ -z "${GIT_PS1}" ]]; then
	export GIT_PS1=1
fi

declare -A syms=( [RA]='' [LA]='' [BRANCH]='' [DIRTY]='✗' [CLEAN]='✓' [STASH]='☇' [AHEAD]='↑' [BHIND]='↓' )

declare -A colors=(
	[BLKF]="\\[$(tput setaf  0)\\]"
	[BLKB]="\\[$(tput setab  0)\\]"
	[REDF]="\\[$(tput setaf  1)\\]"
	[REDB]="\\[$(tput setab  1)\\]"
	[GREF]="\\[$(tput setaf  2)\\]"
	[GREB]="\\[$(tput setab  2)\\]"
	[YELF]="\\[$(tput setaf  3)\\]"
	[YELB]="\\[$(tput setab  3)\\]"
	[BLUF]="\\[$(tput setaf  4)\\]"
	[BLUB]="\\[$(tput setab  4)\\]"
	[PRPF]="\\[$(tput setaf  5)\\]"
	[PRPB]="\\[$(tput setab  5)\\]"
	[AQUF]="\\[$(tput setaf  6)\\]"
	[AQUB]="\\[$(tput setab  6)\\]"
	[GRYF]="\\[$(tput setaf  8)\\]"
	[GRYB]="\\[$(tput setab  8)\\]"
	)

# Nested shell level
if [[ $SHLVL != "1" ]]; then
	readonly shlvl="${colors[GRYB]} ${SHLVL} ${colors[GRYF]}"
else
	readonly shlvl="${colors[GRYF]}${colors[GRYB]} "
fi

# Display Username
readonly usrin="${colors[GREB]}${syms[RA]}${colors[BLKF]} ${HOSTNAME}  ${colors[GREF]}"
readonly clock="${colors[GREF]}${colors[BLKB]}${LA}${colors[GREB]}${colors[BLKF]} \\@"
readonly ps1_2="${colors[BLKB]}${colors[GRYF]}${syms[RA]}\\[$(tput el)\\]\\[$(tput sgr0)\\]"

function git_dirty() {
	local _dirty=$(git status --porcelain 2>/dev/null| wc -l )
	if (( _dirty > 0 ))
	then
		echo "${colors[REDF]} $_dirty${syms[DIRTY]} "
	else
		echo "${colors[GREF]}${syms[CLEAN]} "
	fi
}
function git_stash() {
	local _stash=$(git stash list 2>/dev/null| wc -l)
	if (( _stash > 0 )); then
		echo "${_stash}${syms[STASH]}"
	fi
}

function git_ahead() {
	local _ahead=$(git rev-list "@{u}..HEAD" 2>/dev/null| wc -l)
	if (( _ahead > 0 )); then
		echo "${_ahead}${syms[AHEAD]}"
	fi
}

function git_behind() {
	local _behind=$(git rev-list "HEAD..@{u}" 2>/dev/null| wc -l)
	if (( _behind > 0 )); then
		echo "${_behind}${syms[BHIND]}"
	fi
}

function git_prompt() {
	# GIT STUFF
	local git_repo_name=$(git rev-parse --show-toplevel 2>/dev/null)
	git_repo_name=$(basename ${git_repo_name} 2>/dev/null)
	if [ "$git_repo_name" == "" ] ; then
		return 0
	fi
	local _branch=$(git symbolic-ref HEAD 2>/dev/null )
	_branch=${_branch#refs/heads/} # apparently faster than sed
	echo "${colors[YELB]}${syms[RA]}${colors[BLKF]} ${syms[BRANCH]}${git_repo_name}:${_branch}$(git_dirty &)$(git_stash &)$(git_ahead &)$(git_behind &)${colors[YELF]}"
}

function set_prompt() {

	branch=$(git_prompt&)

	# Virtual Env stuff
	local venv
	if [[ $VIRTUAL_ENV != "" ]]; then
		venv="${colors[PRPB]}${syms[RA]}${colors[BLKF]} ${VIRTUAL_ENV##*/}  ${colors[PRPF]}"
	else
		venv=""
	fi


	local path
	# Check to make sure the path isn't going to run over the clock. Will display
	# current directory and parent directory if it will run over the clock
	path="${colors[BLUB]}${syms[RA]}${colors[BLKF]} \w ${colors[BLUF]}"

	local ps1_1 ps1_1_2
	ps1_1="\\[$(tput el1)\\]\\[$(tput cub $(tput cols))\\]\\[$(tput hpa 0)\\]${shlvl}${usrin}${branch}${venv}"
	ps1_1_2="${colors[BLKB]}${syms[RA]}\\[$(tput sgr0)\\]"

	local ps1_1 
	ps1_1="${ps1_1}${path}${ps1_1_2}"
	export PS1="${ps1_1}\\r\\n${ps1_2}"
}

	export PS2="${ps1_2}"
	export PROMPT_COMMAND=set_prompt
fi
